// @ts-nocheck
import { createClient } from '@supabase/supabase-js'
import * as fs from 'fs'
import * as path from 'path'
import * as dotenv from 'dotenv'

dotenv.config({ path: '.env.local' })

if (!process.env.NEXT_PUBLIC_SUPABASE_URL || !process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY) {
    console.error('Missing Supabase environment variables')
    process.exit(1)
}

const supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
    {
        auth: {
            persistSession: false
        }
    }
)

async function importPosts() {
    const dumpPath = path.join(process.cwd(), 'firebase_dump.json')
    const dump = JSON.parse(fs.readFileSync(dumpPath, 'utf8'))
    const posts = dump.posts
    const users = dump.users

    // Create a mapping of firebase_uid -> user_id (UUID)
    // Since we inserted users already, we need to fetch them back to get their UUIDs.
    // We can query the users table via Supabase client if we open up access, or use the dump to guess.
    // Actually, wait - we need the REAL UUIDs generated by Supabase (or mapped). 
    // Let's first fetch all users from Supabase to build the map.

    // NOTE: We need to allow public Select on Users table too for this script to work without Service Key.
    // I will assume I need to do that manually via MCP tool first or I will just fail here.
    // Assuming 'users' table is public readable for now or I will add policy.

    console.log('Fetching users from Supabase...')
    const { data: supabaseUsers, error: userError } = await supabase
        .from('users')
        .select('id, firebase_uid')

    if (userError) {
        console.error('Error fetching users:', userError)
        // Fallback: If we can't fetch users, we can't map author_id correctly.
        // But we MUST map it.
        return
    }

    const userMap = new Map()
    supabaseUsers.forEach(u => {
        if (u.firebase_uid) userMap.set(u.firebase_uid, u.id)
    })

    console.log(`Found ${supabaseUsers.length} users in Supabase.`)

    // Chunk array
    const CHUNK_SIZE = 50
    for (let i = 0; i < posts.length; i += CHUNK_SIZE) {
        const chunk = posts.slice(i, i + CHUNK_SIZE)
        console.log(`Processing chunk ${i / CHUNK_SIZE + 1}...`)

        const records = chunk.map(post => {
            let authorId = userMap.get(post.author_id_firebase)
            if (!authorId && supabaseUsers.length > 0) authorId = supabaseUsers[0].id

            return {
                id: post.id,
                title: post.title,
                content: post.content,
                excerpt: post.excerpt,
                slug: post.slug,
                category: post.category,
                tags: post.tags || [],
                featured: post.featured,
                published: post.published,
                image_url: post.image_url,
                featured_image: post.featured_image,
                author_id: authorId,
                author_name: post.author_name,
                read_time: post.read_time ? String(post.read_time) : null,
                created_at: post.created_at,
                updated_at: post.updated_at,
                published_at: post.published_at
            }
        })

        // Try batch insert first
        const { error } = await supabase.from('posts').insert(records)

        if (error) {
            console.error('Batch insert failed, retrying individually...', error.message)

            for (const record of records) {
                try {
                    const { error: singleError } = await supabase.from('posts').insert(record)
                    if (singleError) {
                        if (singleError.code === '23505') { // Unique violation
                            if (singleError.message.includes('posts_pkey')) {
                                console.log(`Skipping duplicate ID: ${record.id}`)
                            } else if (singleError.message.includes('posts_slug_key')) {
                                console.log(`Fixing duplicate slug for: ${record.slug}`)
                                let newSlug = record.slug + '-' + Math.floor(Math.random() * 1000)
                                record.slug = newSlug
                                const { error: retryError } = await supabase.from('posts').insert(record)
                                if (retryError) console.error(`Failed to insert fixed slug ${newSlug}:`, retryError)
                                else console.log(`Inserted with new slug: ${newSlug}`)
                            }
                        } else {
                            console.error(`Failed to insert record ${record.id}:`, singleError)
                        }
                    }
                } catch (err) {
                    console.error('Unexpected error:', err)
                }
            }
        } else {
            console.log(`Uploaded ${records.length} posts.`)
        }
    }
}

importPosts()
